# Algorithm

This is my ropo for algorithm Solutions.

# Hot100 分类

## 1.哈希

1. 两数之和（Map 存储；排序）。
2. 字母异位词分组（排序比较；字母计数）。
3. 最长连续序列（利用哈希表，从最小的开始算）。

## 2.双指针

1. 移动零（双指针，快指针找非 0，慢指针挪位置）。
2. 盛水最多的容器（左右指针夹逼 + 贪心，比我高的我才计算）。
3. 三数之和（排序，不回头式查找，左右指针夹逼，有点二分查找的感觉）。

## 3.滑动窗口

1. 无重复字符的最长子串（滑动窗口，从字符集，也就是哈希集合的角度考虑问题，记录每个字符是否出现过，只要发现 set 里面有重复，那么就一直让左指针去移动）。
2. 找到字符串中所有字母异位词分组（滑动窗口，记录每个字母出现的次数，然后使用 `Arrays.equals` 进行比较）。

## 4.子串/子数组

1. 和为 K 的子数组（前缀和，哈希表记录前缀和出现的次数，注意保存 0）。

## 5.普通数组

1. 最大子数组和（前缀和，找最小的前缀和，注意区分**当前**的前缀和与**过往**前缀和的最小值；动态规划，）。

> 前缀和的关键词的是**连续**。

2. 合并区间（按照左端点排序，记着考虑 `[[1, 4], [2, 3]]` 的情况）。
2. 轮转数组（一维数组轮转；O(1) 空间复杂度的方法使用三次 reverse 即可解决）。
2. 除自身以外数组的乘积（前缀积，后缀积，左右开弓；O(1) 空间复杂度的方法可以利用 res 数组，后缀积需要单独定义一个变量 R）。

## 6.矩阵

1. 矩阵置零（用两个标记数组分别记录每一行和每一列是否有零出现；O(1) 的解法是使用输入 **matrix** 的第一行与第一列记录是否有零出现，然后额外使用两个标记变量分别记录第一行和第一列是否原本包含 0）。
2. 螺旋矩阵（定义变量用来记录遍历了多少，定义变量用来记录是否遍历过，然后定义四个方向 `[row, col]` 进行循环；O(1) 的方法是使用四个变量来记录边界）。
3. 旋转图像（可以找到规律为：对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在第 j 行倒数第 i 列的位置，要注意赋值顺序，`[i][j]` 为逆时针，`[i][j]` 在后为顺时针；第二种方法是先上下翻转，然后主对角线翻转）。
4. 搜索二维矩阵 II（左下角或者右上角起手，根据大小定方向）。

## 7.链表





# Max300 分类









# 附录

## 1.动态规划专题

### 1.1.什么情况下使用动态规划

一般情况下，使用动态规划的三个场景：

1. 求最大值或者最小值。
2. 判断是否可行。
3. 统计方案个数。

一般情况下，不使用动态规划的两个场景：

1. 求出所有具体的方案而非方案的个数。
2. 输入数据是一个集合而不是序列。

> 什么是序列？一种数据结构，数据按顺序排列，序列中数据的顺序是十分重要的。
>
> 什么是集合？一种数据结构，数据之间没有什么关系，仅仅是聚合在一起。

### 1.2.动态规划的思路

动态规划其实就是**带备忘录的递归**。

做动态规划，要学会定义**子问题**，子问题要保证无后效性。什么是动态规划的无后效性？为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。

因此，考虑动态规划的转移方程时，需要明白：

* 首先一定要把前面的计算结果利用起来（分解子问题）。
* 然后**考虑一个新的元素加进来之后**，如何结合前驱元素和结果计算新的结果（其实换句话说，就是从**最后一步**入手开始考虑）



